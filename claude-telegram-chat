#!/bin/bash
#
# Claude Code Telegram èŠå¤©æ¨¡å¼
# æŒç»­çš„Telegram â†” Claude Code åŒå‘å¯¹è¯
#

# è·å–è„šæœ¬æ‰€åœ¨ç›®å½•
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# åŠ è½½é…ç½®
CONFIG_FILE="$SCRIPT_DIR/config.sh"
if [ ! -f "$CONFIG_FILE" ]; then
    echo "é”™è¯¯ï¼šé…ç½®æ–‡ä»¶ config.sh ä¸å­˜åœ¨"
    exit 1
fi
source "$CONFIG_FILE"

# æ£€æŸ¥é…ç½®
if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_USER_KEY" ]; then
    echo "é”™è¯¯ï¼šTelegramé…ç½®ä¸å®Œæ•´"
    exit 1
fi

# å¯¼å‡ºç¯å¢ƒå˜é‡
export TELEGRAM_BOT_TOKEN="$TELEGRAM_BOT_TOKEN"
export TELEGRAM_USER_KEY="$TELEGRAM_USER_KEY"
export CC_HOOKS_NOTIFY="on"

# æ—¥å¿—
LOG_FILE="$SCRIPT_DIR/logs/chat_session.log"
mkdir -p "$(dirname "$LOG_FILE")"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
    echo "$1"
}

# å‘é€å¯åŠ¨æ¶ˆæ¯
log "å¯åŠ¨TelegramèŠå¤©æ¨¡å¼"
python3 "$SCRIPT_DIR/telegram_bridge.py" send "ğŸš€ Claude CodeèŠå¤©æ¨¡å¼å¯åŠ¨

ç°åœ¨ä½ å¯ä»¥ï¼š
1. åœ¨Telegramä¸­å‘é€æ¶ˆæ¯
2. ç³»ç»Ÿä¼šå¯åŠ¨Claude Codeå¤„ç†ä½ çš„è¯·æ±‚  
3. å¤„ç†å®Œæˆåä¼šé€šè¿‡é€šçŸ¥å‘é€ç»“æœ
4. å‘é€ 'quit' é€€å‡ºèŠå¤©æ¨¡å¼

ğŸ’¡ æ¯æ¡æ¶ˆæ¯éƒ½ä¼šå¯åŠ¨ä¸€ä¸ªæ–°çš„Claudeä¼šè¯"

echo "ğŸ¤– Claude Code TelegramèŠå¤©æ¨¡å¼"
echo "=================================="
echo "ç›‘å¬Telegramæ¶ˆæ¯ä¸­..."
echo "æŒ‰ Ctrl+C é€€å‡º"
echo ""

# æ¸…ç†å‡½æ•°
cleanup() {
    log "èŠå¤©æ¨¡å¼é€€å‡º"
    python3 "$SCRIPT_DIR/telegram_bridge.py" send "ğŸ›‘ Claude CodeèŠå¤©æ¨¡å¼å·²é€€å‡º"
    exit 0
}
trap cleanup SIGINT SIGTERM EXIT

# è·å–åˆå§‹update_id
LAST_UPDATE_ID=$(python3 -c "
from telegram_bridge import TelegramBridge
bridge = TelegramBridge()
updates = bridge.get_updates(timeout=1)
if updates:
    print(max(update.get('update_id', 0) for update in updates))
else:
    print(0)
")

log "åˆå§‹update_id: $LAST_UPDATE_ID"

# ä¸»å¾ªç¯ï¼šæŒç»­ç›‘å¬æ¶ˆæ¯
while true; do
    # è·å–æ–°æ¶ˆæ¯
    NEW_MESSAGES=$(python3 -c "
import sys
sys.path.append('$SCRIPT_DIR')
from telegram_bridge import TelegramBridge

bridge = TelegramBridge()
updates = bridge.get_updates(offset=$LAST_UPDATE_ID + 1, timeout=5)

messages = []
max_id = $LAST_UPDATE_ID

for update in updates:
    max_id = max(max_id, update.get('update_id', 0))
    
    if 'message' in update:
        msg = update['message']
        if (msg.get('chat', {}).get('id') == int(bridge.chat_id) and 
            'text' in msg and 
            not msg.get('from', {}).get('is_bot', False)):
            
            text = msg['text']
            if bridge.user_key:
                text = bridge._clean_reply_text(text)
            
            if text.strip():
                messages.append(text.strip())

# è¾“å‡ºæ ¼å¼: update_id|message1|message2|...
if messages:
    print(f'{max_id}|' + '|'.join(messages))
else:
    print(f'{max_id}|')
" 2>/dev/null)

    if [ -n "$NEW_MESSAGES" ]; then
        # è§£æç»“æœ
        IFS='|' read -r NEW_UPDATE_ID MESSAGES <<< "$NEW_MESSAGES"
        LAST_UPDATE_ID="$NEW_UPDATE_ID"
        
        # å¤„ç†æ¯æ¡æ¶ˆæ¯
        if [ -n "$MESSAGES" ]; then
            IFS='|' read -ra MSG_ARRAY <<< "$MESSAGES"
            for message in "${MSG_ARRAY[@]}"; do
                if [ -n "$message" ]; then
                    log "æ”¶åˆ°æ¶ˆæ¯: $message"
                    
                    # æ£€æŸ¥é€€å‡ºå‘½ä»¤
                    if [[ "$message" =~ ^(quit|exit|é€€å‡º|/quit|/exit)$ ]]; then
                        log "æ”¶åˆ°é€€å‡ºå‘½ä»¤"
                        exit 0
                    fi
                    
                    # å¯åŠ¨Claude Codeå¤„ç†æ¶ˆæ¯
                    log "å¯åŠ¨Claude Codeå¤„ç†: $message"
                    echo "å¤„ç†ä¸­: $message"
                    
                    # åœ¨åå°å¯åŠ¨Claude Code
                    (
                        echo "$message" | claude code 2>&1
                        log "Claude Codeå¤„ç†å®Œæˆ: $message"
                    ) &
                    
                    # ç­‰å¾…ä¸€ä¸‹é¿å…å¹¶å‘è¿‡å¤š
                    sleep 2
                fi
            done
        fi
    fi
    
    # çŸ­æš‚ä¼‘æ¯
    sleep 1
done