# Design 2-1: Implement JWT Token Generation and Validation

## Requirements
- Generate secure JWT tokens for authenticated users
- Validate tokens on protected routes
- Support token expiration and refresh
- Handle JWT secret from environment or file

## Solution

### JWT Authentication Manager (src/auth.js)
```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const fs = require('fs');

class AuthManager {
  constructor() {
    this.users = new Map(); // In-memory user store for MVP
    this.sessions = new Map();
    this.failedAttempts = new Map();
    this.jwtSecret = this.loadJWTSecret();
  }
  
  loadJWTSecret() {
    // Priority: JWT_SECRET_FILE > JWT_SECRET > default (dev only)
    if (process.env.JWT_SECRET_FILE) {
      try {
        return fs.readFileSync(process.env.JWT_SECRET_FILE, 'utf8').trim();
      } catch (error) {
        throw new Error('JWT secret file not accessible');
      }
    }
    
    if (process.env.JWT_SECRET) {
      return process.env.JWT_SECRET;
    }
    
    if (process.env.NODE_ENV === 'production') {
      throw new Error('JWT secret must be provided in production');
    }
    
    console.warn('WARNING: Using default JWT secret. DO NOT use in production!');
    return 'default-dev-secret-change-this';
  }
  
  generateToken(payload) {
    return jwt.sign(
      payload,
      this.jwtSecret,
      { 
        expiresIn: process.env.JWT_EXPIRES_IN || '24h',
        issuer: 'web-terminal',
        audience: 'web-terminal-client'
      }
    );
  }
  
  verifyToken(token) {
    try {
      return jwt.verify(token, this.jwtSecret, {
        issuer: 'web-terminal',
        audience: 'web-terminal-client'
      });
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Token expired');
      }
      if (error.name === 'JsonWebTokenError') {
        throw new Error('Invalid token');
      }
      throw error;
    }
  }
  
  async hashPassword(password) {
    const rounds = parseInt(process.env.BCRYPT_ROUNDS) || 10;
    return bcrypt.hash(password, rounds);
  }
  
  async verifyPassword(password, hash) {
    return bcrypt.compare(password, hash);
  }
  
  // Express middleware
  authMiddleware() {
    return (req, res, next) => {
      const token = req.headers.authorization?.replace('Bearer ', '');
      
      if (!token) {
        return res.status(401).json({ error: 'No token provided' });
      }
      
      try {
        const payload = this.verifyToken(token);
        req.user = payload;
        next();
      } catch (error) {
        return res.status(401).json({ error: error.message });
      }
    };
  }
  
  // Socket.IO middleware
  socketAuthMiddleware() {
    return (socket, next) => {
      const token = socket.handshake.auth.token;
      
      if (!token) {
        return next(new Error('No token provided'));
      }
      
      try {
        const payload = this.verifyToken(token);
        socket.user = payload;
        next();
      } catch (error) {
        next(new Error(error.message));
      }
    };
  }
}

module.exports = AuthManager;
```

## Tests

### JWT Token Tests (tests/unit/auth.test.js)
```javascript
const AuthManager = require('../../src/auth');

describe('JWT Token Management', () => {
  let authManager;
  
  beforeEach(() => {
    process.env.JWT_SECRET = 'test-secret';
    authManager = new AuthManager();
  });
  
  describe('Token Generation', () => {
    test('should generate a valid JWT token', () => {
      const payload = { username: 'testuser', role: 'user' };
      const token = authManager.generateToken(payload);
      
      expect(token).toBeDefined();
      expect(typeof token).toBe('string');
      expect(token.split('.')).toHaveLength(3); // JWT format
    });
    
    test('should include custom claims', () => {
      const payload = { username: 'testuser', role: 'admin' };
      const token = authManager.generateToken(payload);
      const decoded = authManager.verifyToken(token);
      
      expect(decoded.username).toBe('testuser');
      expect(decoded.role).toBe('admin');
      expect(decoded.iss).toBe('web-terminal');
      expect(decoded.aud).toBe('web-terminal-client');
    });
  });
  
  describe('Token Validation', () => {
    test('should verify a valid token', () => {
      const payload = { username: 'testuser' };
      const token = authManager.generateToken(payload);
      const decoded = authManager.verifyToken(token);
      
      expect(decoded.username).toBe('testuser');
    });
    
    test('should reject an invalid token', () => {
      const invalidToken = 'invalid.token.here';
      
      expect(() => {
        authManager.verifyToken(invalidToken);
      }).toThrow('Invalid token');
    });
    
    test('should reject an expired token', (done) => {
      process.env.JWT_EXPIRES_IN = '1ms';
      const newAuthManager = new AuthManager();
      const token = newAuthManager.generateToken({ username: 'test' });
      
      setTimeout(() => {
        expect(() => {
          newAuthManager.verifyToken(token);
        }).toThrow('Token expired');
        done();
      }, 10);
    });
    
    test('should reject token with wrong secret', () => {
      const token = authManager.generateToken({ username: 'test' });
      
      process.env.JWT_SECRET = 'wrong-secret';
      const newAuthManager = new AuthManager();
      
      expect(() => {
        newAuthManager.verifyToken(token);
      }).toThrow('Invalid token');
    });
  });
  
  describe('Password Hashing', () => {
    test('should hash password', async () => {
      const password = 'testPassword123';
      const hash = await authManager.hashPassword(password);
      
      expect(hash).toBeDefined();
      expect(hash).not.toBe(password);
      expect(hash.length).toBeGreaterThan(50); // bcrypt hash length
    });
    
    test('should verify correct password', async () => {
      const password = 'testPassword123';
      const hash = await authManager.hashPassword(password);
      const isValid = await authManager.verifyPassword(password, hash);
      
      expect(isValid).toBe(true);
    });
    
    test('should reject incorrect password', async () => {
      const password = 'testPassword123';
      const hash = await authManager.hashPassword(password);
      const isValid = await authManager.verifyPassword('wrongPassword', hash);
      
      expect(isValid).toBe(false);
    });
  });
  
  describe('Middleware', () => {
    test('should authenticate valid token in Express middleware', () => {
      const token = authManager.generateToken({ username: 'test' });
      const req = {
        headers: { authorization: `Bearer ${token}` }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      const next = jest.fn();
      
      const middleware = authManager.authMiddleware();
      middleware(req, res, next);
      
      expect(req.user).toBeDefined();
      expect(req.user.username).toBe('test');
      expect(next).toHaveBeenCalled();
    });
    
    test('should reject missing token in Express middleware', () => {
      const req = { headers: {} };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      const next = jest.fn();
      
      const middleware = authManager.authMiddleware();
      middleware(req, res, next);
      
      expect(res.status).toHaveBeenCalledWith(401);
      expect(res.json).toHaveBeenCalledWith({ error: 'No token provided' });
      expect(next).not.toHaveBeenCalled();
    });
  });
  
  describe('JWT Secret Loading', () => {
    test('should load secret from file if specified', () => {
      const fs = require('fs');
      jest.spyOn(fs, 'readFileSync').mockReturnValue('file-secret\n');
      
      process.env.JWT_SECRET_FILE = '/path/to/secret';
      const newAuthManager = new AuthManager();
      
      expect(newAuthManager.jwtSecret).toBe('file-secret');
    });
    
    test('should throw in production without secret', () => {
      delete process.env.JWT_SECRET;
      delete process.env.JWT_SECRET_FILE;
      process.env.NODE_ENV = 'production';
      
      expect(() => {
        new AuthManager();
      }).toThrow('JWT secret must be provided in production');
    });
  });
});
```

## Implementation Priority
1. Basic token generation and validation
2. Password hashing utilities
3. Middleware functions
4. Secret loading logic
5. Error handling

## Security Considerations
- Use strong secrets in production
- Implement token refresh mechanism
- Add token blacklist for logout
- Monitor failed authentication attempts
- Use secure token storage on client side