# Design 3-1: Implement PTY Process Management with node-pty

## Requirements
- Create and manage PTY (pseudo-terminal) processes
- Support multiple platforms (Linux, macOS, Windows)
- Handle process lifecycle (create, destroy, cleanup)
- Implement proper error handling and resource management

## Solution

### Terminal Manager (src/terminal.js)
```javascript
const pty = require('node-pty');
const EventEmitter = require('events');

class TerminalManager extends EventEmitter {
  constructor() {
    super();
    this.terminals = new Map(); // terminalId -> terminal instance
    this.setupCleanup();
  }
  
  setupCleanup() {
    // Cleanup on process exit
    process.on('exit', () => this.cleanup());
    process.on('SIGINT', () => this.cleanup());
    process.on('SIGTERM', () => this.cleanup());
  }
  
  createTerminal(terminalId, options = {}) {
    // Check if terminal already exists
    if (this.terminals.has(terminalId)) {
      throw new Error(`Terminal ${terminalId} already exists`);
    }
    
    // Platform-specific shell selection
    const defaultShell = this.getDefaultShell();
    
    // Terminal options
    const ptyOptions = {
      name: 'xterm-256color',
      cols: options.cols || 80,
      rows: options.rows || 24,
      cwd: options.cwd || process.env.HOME,
      env: {
        ...process.env,
        TERM: 'xterm-256color',
        COLORTERM: 'truecolor',
        LANG: process.env.LANG || 'en_US.UTF-8'
      }
    };
    
    try {
      // Create PTY process
      const ptyProcess = pty.spawn(
        options.shell || defaultShell,
        options.args || [],
        ptyOptions
      );
      
      // Create terminal instance
      const terminal = {
        id: terminalId,
        pty: ptyProcess,
        createdAt: Date.now(),
        lastActivity: Date.now(),
        cols: ptyOptions.cols,
        rows: ptyOptions.rows,
        buffer: [], // Output buffer for recovery
        maxBufferSize: 1000 // Keep last 1000 lines
      };
      
      // Handle PTY events
      this.setupTerminalHandlers(terminal);
      
      // Store terminal
      this.terminals.set(terminalId, terminal);
      
      this.emit('terminal:created', { terminalId });
      
      return terminal;
    } catch (error) {
      throw new Error(`Failed to create terminal: ${error.message}`);
    }
  }
  
  setupTerminalHandlers(terminal) {
    // Handle data from PTY
    terminal.pty.onData((data) => {
      terminal.lastActivity = Date.now();
      
      // Add to buffer for recovery
      this.addToBuffer(terminal, data);
      
      // Emit data event
      this.emit('terminal:data', {
        terminalId: terminal.id,
        data
      });
    });
    
    // Handle PTY exit
    terminal.pty.onExit(({ exitCode, signal }) => {
      this.emit('terminal:exit', {
        terminalId: terminal.id,
        exitCode,
        signal
      });
      
      // Clean up terminal
      this.destroyTerminal(terminal.id);
    });
  }
  
  addToBuffer(terminal, data) {
    // Split data into lines and add to buffer
    const lines = data.split('\n');
    terminal.buffer.push(...lines);
    
    // Trim buffer if too large
    if (terminal.buffer.length > terminal.maxBufferSize) {
      terminal.buffer = terminal.buffer.slice(-terminal.maxBufferSize);
    }
  }
  
  writeToTerminal(terminalId, data) {
    const terminal = this.terminals.get(terminalId);
    
    if (!terminal) {
      throw new Error(`Terminal ${terminalId} not found`);
    }
    
    try {
      terminal.pty.write(data);
      terminal.lastActivity = Date.now();
    } catch (error) {
      throw new Error(`Failed to write to terminal: ${error.message}`);
    }
  }
  
  resizeTerminal(terminalId, cols, rows) {
    const terminal = this.terminals.get(terminalId);
    
    if (!terminal) {
      throw new Error(`Terminal ${terminalId} not found`);
    }
    
    try {
      terminal.pty.resize(cols, rows);
      terminal.cols = cols;
      terminal.rows = rows;
      terminal.lastActivity = Date.now();
      
      this.emit('terminal:resized', { terminalId, cols, rows });
    } catch (error) {
      throw new Error(`Failed to resize terminal: ${error.message}`);
    }
  }
  
  getTerminal(terminalId) {
    return this.terminals.get(terminalId);
  }
  
  getTerminalBuffer(terminalId) {
    const terminal = this.terminals.get(terminalId);
    return terminal ? terminal.buffer.join('\n') : '';
  }
  
  destroyTerminal(terminalId) {
    const terminal = this.terminals.get(terminalId);
    
    if (!terminal) {
      return;
    }
    
    try {
      // Kill PTY process
      if (!terminal.pty.exitCode) {
        terminal.pty.kill();
      }
    } catch (error) {
      console.error(`Error killing terminal ${terminalId}:`, error);
    }
    
    // Remove from map
    this.terminals.delete(terminalId);
    
    this.emit('terminal:destroyed', { terminalId });
  }
  
  getDefaultShell() {
    if (process.platform === 'win32') {
      return process.env.COMSPEC || 'cmd.exe';
    }
    return process.env.SHELL || '/bin/bash';
  }
  
  getActiveTerminals() {
    return Array.from(this.terminals.keys());
  }
  
  getTerminalStats() {
    const stats = {
      total: this.terminals.size,
      terminals: []
    };
    
    for (const [id, terminal] of this.terminals) {
      stats.terminals.push({
        id,
        createdAt: terminal.createdAt,
        lastActivity: terminal.lastActivity,
        cols: terminal.cols,
        rows: terminal.rows,
        bufferSize: terminal.buffer.length
      });
    }
    
    return stats;
  }
  
  cleanup() {
    // Destroy all terminals
    for (const terminalId of this.terminals.keys()) {
      this.destroyTerminal(terminalId);
    }
  }
  
  // Clean up idle terminals
  cleanupIdleTerminals(maxIdleTime = 30 * 60 * 1000) { // 30 minutes
    const now = Date.now();
    const toCleanup = [];
    
    for (const [id, terminal] of this.terminals) {
      if (now - terminal.lastActivity > maxIdleTime) {
        toCleanup.push(id);
      }
    }
    
    for (const id of toCleanup) {
      console.log(`Cleaning up idle terminal: ${id}`);
      this.destroyTerminal(id);
    }
    
    return toCleanup.length;
  }
}

module.exports = TerminalManager;
```

## Tests

### PTY Management Tests (tests/unit/terminal.test.js)
```javascript
const TerminalManager = require('../../src/terminal');
const crypto = require('crypto');

describe('PTY Process Management', () => {
  let terminalManager;
  let terminalId;
  
  beforeEach(() => {
    terminalManager = new TerminalManager();
    terminalId = crypto.randomUUID();
  });
  
  afterEach(() => {
    terminalManager.cleanup();
  });
  
  describe('Terminal Creation', () => {
    test('should create a new terminal', () => {
      const terminal = terminalManager.createTerminal(terminalId);
      
      expect(terminal).toBeDefined();
      expect(terminal.id).toBe(terminalId);
      expect(terminal.pty).toBeDefined();
      expect(terminal.cols).toBe(80);
      expect(terminal.rows).toBe(24);
    });
    
    test('should create terminal with custom options', () => {
      const options = {
        cols: 120,
        rows: 40,
        cwd: '/tmp'
      };
      
      const terminal = terminalManager.createTerminal(terminalId, options);
      
      expect(terminal.cols).toBe(120);
      expect(terminal.rows).toBe(40);
    });
    
    test('should throw error for duplicate terminal ID', () => {
      terminalManager.createTerminal(terminalId);
      
      expect(() => {
        terminalManager.createTerminal(terminalId);
      }).toThrow(`Terminal ${terminalId} already exists`);
    });
    
    test('should emit terminal:created event', (done) => {
      terminalManager.on('terminal:created', ({ terminalId: id }) => {
        expect(id).toBe(terminalId);
        done();
      });
      
      terminalManager.createTerminal(terminalId);
    });
  });
  
  describe('Terminal I/O', () => {
    test('should write data to terminal', () => {
      const terminal = terminalManager.createTerminal(terminalId);
      
      expect(() => {
        terminalManager.writeToTerminal(terminalId, 'echo "test"\n');
      }).not.toThrow();
    });
    
    test('should receive data from terminal', (done) => {
      terminalManager.on('terminal:data', ({ terminalId: id, data }) => {
        expect(id).toBe(terminalId);
        expect(typeof data).toBe('string');
        done();
      });
      
      const terminal = terminalManager.createTerminal(terminalId);
      terminalManager.writeToTerminal(terminalId, 'echo "test"\n');
    });
    
    test('should buffer terminal output', (done) => {
      const terminal = terminalManager.createTerminal(terminalId);
      
      terminalManager.on('terminal:data', () => {
        setTimeout(() => {
          const buffer = terminalManager.getTerminalBuffer(terminalId);
          expect(buffer).toContain('test');
          done();
        }, 100);
      });
      
      terminalManager.writeToTerminal(terminalId, 'echo "test"\n');
    });
    
    test('should throw error for non-existent terminal', () => {
      expect(() => {
        terminalManager.writeToTerminal('invalid-id', 'data');
      }).toThrow('Terminal invalid-id not found');
    });
  });
  
  describe('Terminal Resize', () => {
    test('should resize terminal', () => {
      const terminal = terminalManager.createTerminal(terminalId);
      
      terminalManager.resizeTerminal(terminalId, 100, 50);
      
      expect(terminal.cols).toBe(100);
      expect(terminal.rows).toBe(50);
    });
    
    test('should emit terminal:resized event', (done) => {
      terminalManager.on('terminal:resized', ({ terminalId: id, cols, rows }) => {
        expect(id).toBe(terminalId);
        expect(cols).toBe(100);
        expect(rows).toBe(50);
        done();
      });
      
      terminalManager.createTerminal(terminalId);
      terminalManager.resizeTerminal(terminalId, 100, 50);
    });
  });
  
  describe('Terminal Lifecycle', () => {
    test('should destroy terminal', () => {
      terminalManager.createTerminal(terminalId);
      terminalManager.destroyTerminal(terminalId);
      
      expect(terminalManager.getTerminal(terminalId)).toBeUndefined();
    });
    
    test('should emit terminal:destroyed event', (done) => {
      terminalManager.on('terminal:destroyed', ({ terminalId: id }) => {
        expect(id).toBe(terminalId);
        done();
      });
      
      terminalManager.createTerminal(terminalId);
      terminalManager.destroyTerminal(terminalId);
    });
    
    test('should handle terminal exit', (done) => {
      terminalManager.on('terminal:exit', ({ terminalId: id }) => {
        expect(id).toBe(terminalId);
        done();
      });
      
      const terminal = terminalManager.createTerminal(terminalId);
      terminalManager.writeToTerminal(terminalId, 'exit\n');
    });
  });
  
  describe('Terminal Management', () => {
    test('should get active terminals', () => {
      const id1 = crypto.randomUUID();
      const id2 = crypto.randomUUID();
      
      terminalManager.createTerminal(id1);
      terminalManager.createTerminal(id2);
      
      const active = terminalManager.getActiveTerminals();
      
      expect(active).toContain(id1);
      expect(active).toContain(id2);
      expect(active).toHaveLength(2);
    });
    
    test('should get terminal stats', () => {
      terminalManager.createTerminal(terminalId);
      
      const stats = terminalManager.getTerminalStats();
      
      expect(stats.total).toBe(1);
      expect(stats.terminals).toHaveLength(1);
      expect(stats.terminals[0].id).toBe(terminalId);
    });
    
    test('should cleanup idle terminals', (done) => {
      const terminal = terminalManager.createTerminal(terminalId);
      terminal.lastActivity = Date.now() - 31 * 60 * 1000; // 31 minutes ago
      
      const cleaned = terminalManager.cleanupIdleTerminals();
      
      expect(cleaned).toBe(1);
      expect(terminalManager.getTerminal(terminalId)).toBeUndefined();
      done();
    });
  });
  
  describe('Platform Compatibility', () => {
    test('should select correct default shell', () => {
      const originalPlatform = process.platform;
      
      // Test Windows
      Object.defineProperty(process, 'platform', { value: 'win32' });
      expect(terminalManager.getDefaultShell()).toMatch(/cmd\.exe|powershell\.exe/);
      
      // Test Unix-like
      Object.defineProperty(process, 'platform', { value: 'darwin' });
      expect(terminalManager.getDefaultShell()).toMatch(/\/bin\/(bash|zsh|sh)/);
      
      // Restore
      Object.defineProperty(process, 'platform', { value: originalPlatform });
    });
  });
});
```

## Implementation Notes
1. Use node-pty for cross-platform PTY support
2. Implement proper cleanup on process exit
3. Buffer output for session recovery
4. Handle platform-specific shell selection
5. Track terminal activity for idle cleanup

## Error Handling
- Validate terminal ID before operations
- Handle PTY spawn failures gracefully
- Clean up resources on errors
- Log errors for debugging

## Performance Considerations
- Limit buffer size to prevent memory issues
- Implement idle terminal cleanup
- Use event emitters for async communication
- Consider terminal pooling for high load